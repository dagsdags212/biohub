<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jan Emmanuel Samson">
<meta name="dcterms.date" content="2024-08-26">
<meta name="description" content="String preprocessing for efficient pattern matching.">

<title>The Z-Algorithm – BioHub</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">BioHub</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../notebook.html"> 
<span class="menu-text">Notebook</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../rosalind.html"> 
<span class="menu-text">Rosalind</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://x.com/dagsdags13" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-twitter"></i></a>
    <a href="https://github.com/dagsdags212" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The Z-Algorithm</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Algorithms</div>
    <div class="quarto-category">Alignment</div>
    <div class="quarto-category">Data Structures</div>
  </div>
  </div>

<div>
  <div class="description">
    String preprocessing for efficient pattern matching.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jan Emmanuel Samson </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 26, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="string-preprocessing" class="level1">
<h1>String Preprocessing</h1>
<p>A few extact-matching algorithms rely on a fundamental preprocessing step to compute the maximum number of allowable skips in string-to-substring comparisons. Text preprocessing is usually done to only the query string, making it ideal for applications where the query is smaller than the text itself. Such is the case when trying to align short reads to a significantly larger reference genome.</p>
<p>Algorithms that preprocess only the query string are termed <strong>online</strong> while those that preprocess the larger text are <strong>offline</strong>. Some examples of online algorithms include:</p>
<ul>
<li>Knuth-Morris-Pratt</li>
<li>Boyer-Moore</li>
</ul>
<p>Online algorithms preprocess the query string using the <em>Z function</em>. Let’s look at how the algorithm works.</p>
<section id="terminology" class="level2">
<h2 class="anchored" data-anchor-id="terminology">Terminology</h2>
<p>In pattern matching, we are interested in two separate strings where one string is ‘smaller’ than the other. The context of string size is limited to the number of characters used in building the string. I will be using notation for representing such string.</p>
<div class="columns">
<div class="column" style="width:50%;">
<dl>
<dt>Reference string (S)</dt>
<dd>
The references string or the larger of the two strings.
</dd>
<dt>Query string (T)</dt>
<dd>
The query string or the shorter of the two strings.
</dd>
<dt>k</dt>
<dd>
Index position of the first character of a substring, relative to the start of the reference string. Given <span class="math inline">\(S = \text{abracadabra}\)</span>, the value of <span class="math inline">\(k\)</span> for substring <span class="math inline">\(\text{adab}\)</span> is 6.
</dd>
</dl>
</div><div class="column" style="width:50%;">
<dl>
<dt>|S|</dt>
<dd>
The length of the reference string. This can be generalized to other stings as well. Any variable enclosed between pipes (<code>|</code>) refers to the length of that string.
</dd>
<dt>S[i:j]</dt>
<dd>
A subset of the reference string that stars at index i and ends at index j, inclusive. Also generalizable to other strings. For example, if <span class="math inline">\(S = \text{abracadabra}\)</span> then S[6:9] is just the substring <span class="math inline">\(\text{adab}\)</span>.
</dd>
</dl>
</div>
</div>
</section>
<section id="the-z-box" class="level2">
<h2 class="anchored" data-anchor-id="the-z-box">The Z-box</h2>
<p>Given a string <em>S</em> and a position <em>i</em> &gt; 1 let <span class="math inline">\(Z_i(S)\)</span> be the length of the longest substring of <em>S</em> that starts at <em>i</em> and matches a prefix of <em>S</em>.</p>
<p>In other words, <span class="math inline">\(Z_i(S)\)</span> is the length of the longest prefix of <em>S[i..|S|]</em> that matches a prefix of <em>S</em>. For example, when <span class="math inline">\(S = \text{aabcaabxaaz}\)</span> then</p>
<p><span class="math display">\[
\begin{aligned}
Z_5(S) = 3 \\
Z_6(S) = 1 \\
Z_7(S) = 0 \\
Z_8(S) = 0 \\
Z_9(S) = 2 \\
\end{aligned}
\]</span></p>
<p>The length of <em>S</em> can be represented as a 1-dimensional line as seen in the figure below. Each span of each z-box should be within the line.</p>
<p><img src="../assets/zbox.png" class="img-fluid"></p>
<p>Each solid box represents a substring of <em>S</em> that matches a prefix of <em>S</em> and that starts between positions 2 and <em>i</em>. The right-most end of any Z-box is denoted as <span class="math inline">\(r_i\)</span> and the left-most end is denoted as <span class="math inline">\(l_i\)</span>. The substring that occurs between <span class="math inline">\(r_i\)</span> and <span class="math inline">\(l_i\)</span> is labelled as substring <span class="math inline">\(α\)</span>.</p>
</section>
<section id="computing-z_i" class="level2">
<h2 class="anchored" data-anchor-id="computing-z_i">Computing <span class="math inline">\(Z_i\)</span></h2>
<p>Given a string <em>S</em> with length |<em>S</em>|, we compute <span class="math inline">\(Z_i\)</span>, <span class="math inline">\(r_i\)</span>, and <span class="math inline">\(l_i\)</span> for each successive position <em>i</em>, starting from <span class="math inline">\(i=2\)</span>. An empty array of length |<em>S</em>| will be initialized to store each compute value of <span class="math inline">\(Z_i\)</span>.</p>
<p>For any iteration <em>i</em>, the algorithm would only need to update the values of <span class="math inline">\(r_i\)</span> and <span class="math inline">\(l_i\)</span> based on the values for the previous iteration <em>j</em>. So for any iteration <em>i</em> where a new Z-box is discovered, the variable <em>r</em> will be incremeted to the end of the Z-box and variable <em>l</em> is set to the current value of <em>i</em>. Given:</p>
<center>
<p><span class="math inline">\(S = \text{CAGTCAGCA}\)</span></p>
</center>
<p>We compute for the Z values of the substrings highlighted in blue:</p>
<center>
<p><span class="text md">C </span><span class="blue md">A G T C A G C A </span><br> <span class="text md">C A </span><span class="blue md">G T C A G C A </span><br> <span class="text md">C A G </span><span class="blue md">T C A G C A </span><br> <span class="text md">C A G T </span><span class="blue md">C A G C A </span><br> <span class="text md">C A G T C </span><span class="blue md">A G C A</span><br> <span class="text md">C A G T C A </span><span class="blue md">G C A</span><br></p>
</center>
<p>We first compute for Z at the second index of the string (<span class="math inline">\(Z_2\)</span>). Since this is the first iteration, we explicitly compare the characters of <span class="math inline">\(S[2..|S|]\)</span> and <span class="math inline">\(S[1..|S|]\)</span> from left to right, keeping count of the number of characters that exactly match:</p>
<center>
<div>

</div>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="{col} quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p><span class="peach md">C </span><span class="text md">A G T C A G C A </span><br> <span class="peach md">C </span><span class="text md">A G T C A G C A </span><br> <span class="peach md">C </span><span class="text md">A G T C A G C A </span><br></p>
</div>
<div class="{col} quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p><span class="text md">C </span><span class="blue md">A </span><span class="text md">G T C A G C A </span><br> <span class="text md">C A </span><span class="blue md">G </span><span class="text md">T C A G C A </span><br> <span class="text md">C A G </span><span class="blue md">T </span><span class="text md"> C A G C A </span><br></p>
</div>
</div>
</div>
</center>
<p>The first three iterations show that there are not common characters between the <span class="math inline">\(\text{substring}_i\)</span> and the prefix of <em>S</em>, hence the compute a <span class="math inline">\(Z_i = 0\)</span>. We continue with the next few iterations.</p>
<center>
<div>

</div>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="{col} quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p><span class="peach md">C </span><span class="text md">A G T C A G C A </span><br> <span class="peach md">C A </span><span class="text md">G T C A G C A </span><br> <span class="peach md">C A G </span><span class="text md">T C A G C A </span><br></p>
</div>
<div class="{col} quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p><span class="text md">C A G T </span><span class="blue md">C </span><span class="text md"> A G C A </span><br> <span class="text md">C A G T </span><span class="blue md">C A </span><span class="text md"> G C A </span><br> <span class="text md">C A G T </span><span class="blue md">C A G </span><span class="text md"> C A </span><br></p>
</div>
</div>
</div>
</center>
<p>At <span class="math inline">\(i = 5\)</span>, we see that there is a common substring of length 3 indicated that we found an occurrence of a new z-box. We denote the start of the substring as <em>k</em> and update the values of <em>r</em> and <em>l</em> as follows:</p>
<p><span class="math display">\[
k = 5; z_k = 3
\]</span> <span class="math display">\[
r = k + z_k - 1
\]</span> <span class="math display">\[
l = k
\]</span></p>
<p>We visualize the current z-box as a range within string <em>S</em> bound between indices <em>l</em> and <em>r</em> which in our case is a substring that starts at index 5 and ends at index 7. We represent this substring as <span class="math inline">\(Z[l..r]\)</span> and is color in red below:</p>
<center>
<span class="md">C A G T </span><span class="red md">C A G </span><span class="md">C A </span><br> <span class="text md" style="letter-spacing: 0.05rem;">1 2 3 4 5 6 7 8 9</span><br>
</center>
<p>Since we know that <span class="math inline">\(S[5..7]\)</span> occurs at <span class="math inline">\(S[1..3]\)</span>, we can also be certain that <span class="math inline">\(S[6..7]\)</span> is found at <span class="math inline">\(S[2..3]\)</span>. The same can be said for <span class="math inline">\(S[7]\)</span> and <span class="math inline">\(S[3]\)</span>. This subtlety allows us to update the values of <em>l</em> and <em>r</em> based on previously computed values of Z. We update these variables based on the following conditions:</p>
<ol type="1">
<li>If <span class="math inline">\(k &gt; r\)</span>, explicitly compare characters starting at position <em>k</em> to the character starting at position 1 of string <em>S</em> until a mistmatch is found and assign the count to <span class="math inline">\(Z_k\)</span>. If <span class="math inline">\(Z_k &gt; 0\)</span>, set <span class="math inline">\(r = k + Z_k -1\)</span> and <span class="math inline">\(l = k\)</span>. Otherwise, set <span class="math inline">\(r = 0\)</span> and <span class="math inline">\(l = 0\)</span>.</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/zbox_case1.png" class="img-fluid figure-img"></p>
<figcaption>String S[k..r] is labelled <span class="math inline">\(β\)</span> and also occurs starting at position k’ of S.</figcaption>
</figure>
</div>
<ol start="2" type="1">
<li><p>If <span class="math inline">\(k \le r\)</span>, compute for k’ as <span class="math inline">\(k' = k - l + 1\)</span> and the length of S[k..r] (denoted as <span class="math inline">\(\beta\)</span>). Then following the subconditions:</p>
<ul>
<li>If <span class="math inline">\(Z_{k'} \lt |β|\)</span>, set <span class="math inline">\(Z_k = Z_{k'}\)</span> and leave the values of <em>l</em> and <em>r</em> unchanged.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/zbox_case2a.png" class="img-fluid figure-img"></p>
<figcaption>The longest string starting at k’ that matches a prefix of S is shorter than |<span class="math inline">\(β\)</span>|. In this case, <span class="math inline">\(Z_k = Z_{k'}\)</span>.</figcaption>
</figure>
</div>
<ul>
<li>If <span class="math inline">\(Z_{k'} \ge |β|\)</span>, start comparing the characters starting at positions <span class="math inline">\(r + 1\)</span> and <span class="math inline">\(|β|+1\)</span> of <em>S</em> until a mismatch occurs, storing the index where the first mistmatch occurred at variable <em>q</em>. Set <span class="math inline">\(Z_k = q - k\)</span>, <span class="math inline">\(r = q - 1\)</span> and <span class="math inline">\(l = k\)</span>.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/zbox_case2b.png" class="img-fluid figure-img"></p>
<figcaption>The longest string starting at k’ that matches a prefix of S is at least |<span class="math inline">\(β\)</span>|.</figcaption>
</figure>
</div></li>
</ol>
<p>Continuing our example, we proceed to iteration 6 (<span class="math inline">\(k=6\)</span>) and follow the condition provided. Since <span class="math inline">\(k \le r\)</span> (6 &lt; 7), we compute <em>k’</em> and the length of <span class="math inline">\(β\)</span> as 2 and 3, respectively. We backtrack to the Z-value at index <em>k’</em> which is seen to be <span class="math inline">\(Z_2 = 0\)</span>. This information points us to the first subcondition since <span class="math inline">\(0 &lt; 3\)</span>. Hence we set <span class="math inline">\(Z_6 = Z_2 = 0\)</span> and keep <em>l</em> and <em>r</em> unchanged.</p>
<p>Following the next iteration would point us to the second subcondition where we have to explicitly compare substrings starting from indices 4 and 8 of string <em>S</em>. This immediately leads to a mismatch hence we set <span class="math inline">\(q = 0\)</span> and update the variables <span class="math inline">\(Z_k = 8 - 70\)</span>, <span class="math inline">\(r = 8-1 = 7\)</span>, and <span class="math inline">\(l=7\)</span></p>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<div class="sourceCode" id="annotated-cell-1"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-1-1"><a href="#annotated-cell-1-1"></a><span class="kw">def</span> z(s):</span>
<span id="annotated-cell-1-2"><a href="#annotated-cell-1-2"></a>  <span class="co">"""Use Z-algorithm to preprocess a given string."""</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="1">1</button><span id="annotated-cell-1-3" class="code-annotation-target"><a href="#annotated-cell-1-3"></a>  L <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="annotated-cell-1-4"><a href="#annotated-cell-1-4"></a>  Z <span class="op">=</span> [L] <span class="op">+</span> [<span class="dv">0</span>] <span class="op">*</span> L</span>
<span id="annotated-cell-1-5"><a href="#annotated-cell-1-5"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="2">2</button><span id="annotated-cell-1-6" class="code-annotation-target"><a href="#annotated-cell-1-6"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, L):</span>
<span id="annotated-cell-1-7"><a href="#annotated-cell-1-7"></a>    <span class="cf">if</span> s[i] <span class="op">==</span> s[i<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="annotated-cell-1-8"><a href="#annotated-cell-1-8"></a>      Z[<span class="dv">1</span>] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="annotated-cell-1-9"><a href="#annotated-cell-1-9"></a>    <span class="cf">else</span>:</span>
<span id="annotated-cell-1-10"><a href="#annotated-cell-1-10"></a>      <span class="cf">break</span></span>
<span id="annotated-cell-1-11"><a href="#annotated-cell-1-11"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="3">3</button><span id="annotated-cell-1-12" class="code-annotation-target"><a href="#annotated-cell-1-12"></a>  r, l <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="annotated-cell-1-13"><a href="#annotated-cell-1-13"></a>  <span class="cf">if</span> Z[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="annotated-cell-1-14"><a href="#annotated-cell-1-14"></a>    r, l <span class="op">=</span> Z[<span class="dv">1</span>], <span class="dv">1</span></span>
<span id="annotated-cell-1-15"><a href="#annotated-cell-1-15"></a></span>
<span id="annotated-cell-1-16"><a href="#annotated-cell-1-16"></a>  <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, L):</span>
<span id="annotated-cell-1-17"><a href="#annotated-cell-1-17"></a>    <span class="cf">assert</span> Z[k] <span class="op">==</span> <span class="dv">0</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="4">4</button><span id="annotated-cell-1-18" class="code-annotation-target"><a href="#annotated-cell-1-18"></a>    <span class="cf">if</span> k <span class="op">&gt;</span> r:</span>
<span id="annotated-cell-1-19"><a href="#annotated-cell-1-19"></a>      <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k, <span class="bu">len</span>(s)):</span>
<span id="annotated-cell-1-20"><a href="#annotated-cell-1-20"></a>        <span class="cf">if</span> s[i] <span class="op">==</span> s[i<span class="op">-</span>k]:</span>
<span id="annotated-cell-1-21"><a href="#annotated-cell-1-21"></a>          Z[k] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="annotated-cell-1-22"><a href="#annotated-cell-1-22"></a>        <span class="cf">else</span>:</span>
<span id="annotated-cell-1-23"><a href="#annotated-cell-1-23"></a>          <span class="cf">break</span></span>
<span id="annotated-cell-1-24"><a href="#annotated-cell-1-24"></a>      r, l <span class="op">=</span> k <span class="op">+</span> Z[k] <span class="op">-</span> <span class="dv">1</span>, k</span>
<span id="annotated-cell-1-25"><a href="#annotated-cell-1-25"></a>    <span class="cf">else</span>:</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="5">5</button><span id="annotated-cell-1-26" class="code-annotation-target"><a href="#annotated-cell-1-26"></a>      n_beta <span class="op">=</span> r <span class="op">-</span> k <span class="op">+</span> <span class="dv">1</span></span>
<span id="annotated-cell-1-27"><a href="#annotated-cell-1-27"></a>      Zkp <span class="op">=</span> Z[k<span class="op">-</span>l]</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="6">6</button><span id="annotated-cell-1-28" class="code-annotation-target"><a href="#annotated-cell-1-28"></a>      <span class="cf">if</span> n_beta <span class="op">&gt;</span> Zkp:</span>
<span id="annotated-cell-1-29"><a href="#annotated-cell-1-29"></a>        Z[k] <span class="op">=</span> Zkp</span>
<span id="annotated-cell-1-30"><a href="#annotated-cell-1-30"></a>      <span class="cf">else</span>:</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="7">7</button><span id="annotated-cell-1-31" class="code-annotation-target"><a href="#annotated-cell-1-31"></a>        n_match <span class="op">=</span> <span class="dv">0</span></span>
<span id="annotated-cell-1-32"><a href="#annotated-cell-1-32"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(r<span class="op">+</span><span class="dv">1</span>, <span class="bu">len</span>(s)):</span>
<span id="annotated-cell-1-33"><a href="#annotated-cell-1-33"></a>          <span class="cf">if</span> s[i ] <span class="op">==</span> s[i<span class="op">-</span>k]:</span>
<span id="annotated-cell-1-34"><a href="#annotated-cell-1-34"></a>            n_match <span class="op">+=</span> <span class="dv">1</span></span>
<span id="annotated-cell-1-35"><a href="#annotated-cell-1-35"></a>          <span class="cf">else</span>:</span>
<span id="annotated-cell-1-36"><a href="#annotated-cell-1-36"></a>            <span class="cf">break</span></span>
<span id="annotated-cell-1-37"><a href="#annotated-cell-1-37"></a>        l, r <span class="op">=</span> k, r <span class="op">+</span> n_match</span>
<span id="annotated-cell-1-38"><a href="#annotated-cell-1-38"></a>        Z[k] <span class="op">=</span> r <span class="op">-</span> k <span class="op">+</span> <span class="dv">1</span></span>
<span id="annotated-cell-1-39"><a href="#annotated-cell-1-39"></a>  <span class="cf">return</span> Z</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-1" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="3,4" data-code-annotation="1">Initialize array for storing Z-values.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="6,7,8,9,10" data-code-annotation="2">Naive comparison for first substring.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="12,13,14" data-code-annotation="3">Initialize bounds of the Z-box.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="18,19,20,21,22,23,24" data-code-annotation="4">Case 1.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="26,27" data-code-annotation="5">Case 2.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="28,29" data-code-annotation="6">Case 2a.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="31,32,33,34,35,36,37,38" data-code-annotation="7">Case 2b.</span>
</dd>
</dl>
<div class="refs">

</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
      for (let i=0; i<annoteTargets.length; i++) {
        const annoteTarget = annoteTargets[i];
        const targetCell = annoteTarget.getAttribute("data-target-cell");
        const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
        const contentFn = () => {
          const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          if (content) {
            const tipContent = content.cloneNode(true);
            tipContent.classList.add("code-annotation-tip-content");
            return tipContent.outerHTML;
          }
        }
        const config = {
          allowHTML: true,
          content: contentFn,
          onShow: (instance) => {
            selectCodeLines(instance.reference);
            instance.reference.classList.add('code-annotation-active');
            window.tippy.hideAll();
          },
          onHide: (instance) => {
            unselectCodeLines();
            instance.reference.classList.remove('code-annotation-active');
          },
          maxWidth: 300,
          delay: [50, 0],
          duration: [200, 0],
          offset: [5, 10],
          arrow: true,
          appendTo: function(el) {
            return el.parentElement.parentElement.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'quarto',
          placement: 'right',
          popperOptions: {
            modifiers: [
            {
              name: 'flip',
              options: {
                flipVariations: false, // true by default
                allowedAutoPlacements: ['right'],
                fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
              },
            },
            {
              name: 'preventOverflow',
              options: {
                mainAxis: false,
                altAxis: false
              }
            }
            ]        
          }      
        };
        window.tippy(annoteTarget, config); 
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>