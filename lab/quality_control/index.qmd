---
title: Quality Control and Adapter Trimming
author: Jan Emmanuel Samson
email: jgsamson@up.edu.ph
date: 2025/01/02
last-modified: 2025/01/07
description: "Preprocessing raw sequencing reads for downstream analysis"
categories:
  - sequence-analysis
  - preprocessing
  - CLI
image: assets/cover.webp
toc: true
title-block-banner: true
bibliography: references.bib
---

::: {.callout-tip title="Objective"}
In this tutorial, you will learn some important steps in preparing sequencing reads for downstream analysis. The following steps will be demonstrated with examples:

- exploring the raw data
- removing adapters
- filtering reads based on quality score
- summarizing and exploring filtered data
:::

## Prerequisites

### Downloading Sequencing Reads

In a typical workflow, sequencing reads are downloaded from the [Sequencing Read Archive](https://www.ncbi.nlm.nih.gov/sra). To learn more about fetching data from the SRA, refer to [this article](https://dagsdags212.github.io/biohub/notebook/retrieving_biological_data/). 

In this tutorial, we will be performing quality control on two datasets. The first dataset consists of 100000 single-end reads stored as a single FASTQ file. The second dataset consists of six pair-end FASTQ files generated from an Illumina HiSeq experiment by @glenn2011field.

Create an empty directory and download the sequencing data in FASTQ format using `git`: 
```bash
# Create working directory and navigate to it
mkdir qc && cd qc

# Create directory for storing reads
mkdir reads

# Download sequencing reads for first dataset
git clone https://github.com/bioinfo-dirty-jobs/Data.git se_reads/
mv se_reads/QUALITY/quality_control/f010_raw_mirna.fastq.gz reads/f010_raw_mirna.fastq.gz

# Download sequencing reads for second dataset
wget -O pe_reads.tar.gz https://osf.io/2jc4a/download
tar -xvzf pe_reads.tar.gz
mv data/* reads/

# Remove files not needed for the analysis
rm -rf se_reads/ data/ 
```

The `reads` directory should contain a total of **seven** FASTQ files.

### Project Structure

I often create an `output` directory to store all files generated by the tools I used in the analysis, with each tool having its own subdirectory. For this tutorial, we will be using `fastqc`, `multiqc`, `cutadapt`, and `fastp`. The output for each tools will be stored in a subdirectory (with the same name) under the `output` directory:

```{python}
#| echo: false
!lsd --tree -d ./output
```

### Software

The listed tools can be downloaded from the Bioconda repository:

- [fastqc](https://bioconda.github.io/recipes/fastqc/README.html#package-package%20&#x27;fastqc&#x27;)
- [multiqc](https://bioconda.github.io/recipes/multiqc/README.html#package-package%20&#x27;multiqc&#x27;)
- [cutadapt](https://bioconda.github.io/recipes/cutadapt/README.html#package-package%20&#x27;cutadapt&#x27;)
- [fastp](https://bioconda.github.io/recipes/fastp/README.html#package-package%20&#x27;fastp&#x27;)
- [biostrings](https://bioconda.github.io/recipes/bioconductor-biostrings/README.html#package-package%20&#x27;bioconductor-biostrings&#x27;)

## Workflow

### Exploring Raw Reads

Unzip the FASTQ file using `gunzip`:
```bash
gunzip data/f010_raw_mirna.fastq
```

The file _f010_raw_mirna.fastq.fz_ contains sequencing reads from a microRNA sequencing experiment. View the first 8 rows using the `head` command:
```bash
head -n 8 reads/f010_raw_mirna.fastq
```

```{python}
#| echo: false
! head -n 8 reads/f010_raw_mirna.fastq
```

Count the number of reads in the FASTQ file using `wc`, dividing the output by 4:
```bash
wc -l reads/f010_raw_mirna.fastq
```
```{python}
#| echo: false
! wc -l reads/f010_raw_mirna.fastq
```

The number of reads can be computed directly with the use of `cut` and `expr`:
```bash
expr $(wc -l reads/f010_raw_mirna.fastq | cut -d " " -f 1) / 4
```
```{python}
#| echo: false
! expr $(wc -l reads/f010_raw_mirna.fastq | cut -d " " -f 1) / 4
```

There are a total of 100000 reads in the FASTQ file. Information that summarizes the distribution of quality reads, base composition, and sequence representation can be generated using `fastqc`. We pass in the FASTQ file as the first positional argument and specify the `-o` flag to store our results in a designated directory.
```bash
# Target directory for FastQC report of raw reads
mkdir -p output/fastqc/raw

# Run fastq
fastqc data/f010_raw_mirna.fastq -o output/fastqc/raw
```

The result of running `fastqc` on the unprocessed reads is provided below.

::: {.column-page}

<embed type="text/html" src="output/fastqc/raw/f010_raw_mirna_fastqc.html" width="100%" height="640" />

:::

---

From initial inspection, we observe a wide spread in the distribution of quality scores. The lowest quality score is 9 and the highest is 26, with the majority of reads having a quality score of 26. The output suggests that there are issues with the following metrics:

- _Per base sequence quality_
- _Per base sequence content_
- _Per sequence GC content_
- _Sequence Duplication Levels_
- _Overrepresented sequences_

### Checking for Adapters

There are 2 known adapters used in this experiment:
```markdown
CTGGGAAATCACCATAAACGTGAAATGTCTTTGGATTTGGGAATCTTATAAGTTCTGTATGAGACCACTCTAAAAA
CTTTTTTTCGTCCTTTCCACAAGATATATAAAGCCAAGAAATCGAAATACTTTCAAGTTACGGTAAGC
```

We can verify this by querying our reads against the two adapters using `grep` and counting the number of their occurrence:
```{python}
!grep "CTGGGAAATCACCATAAACGTGAAATGTCTTTGGATTTGGGAATCTTATAAGTTCTGTATGAGACCACTCTAAAAA" data/f010_raw_mirna.fastq | wc -l
```

```{python}
!grep "CTTTTTTTCGTCCTTTCCACAAGATATATAAAGCCAAGAAATCGAAATACTTTCAAGTTACGGTAAGC" data/f010_raw_mirna.fastq | wc -l
```

The adapters seem to systematically appear at the flanking ends of the reads, suggesting that these sequences were artificially ligated. We must also check if the same set of adapters are found in the _reverse_, _complement_, or _reverse complement_  of each read. For this, we compute the reversed and completemented reads using the R package `biostrings`.

```R
library(Biostrings)

adapter1 <- DNAString("CTGGGAAATCACCATAAACGTGAAATGTCTTTGGATTTGGGAATCTTATAAGTTCTGTATGAGACCACTCTAAAAA")
paste("Adapter 1 reverse:", reverse(adapter1))
paste("Adapter 1 complement:", complement(adapter1))
paste("Adapter 1 reverse complement:", reverseComplement(adapter1))

adapter2 <- DNAString("CTTTTTTTCGTCCTTTCCACAAGATATATAAAGCCAAGAAATCGAAATACTTTCAAGTTACGGTAAGC")
paste("Adapter 2 reverse:", reverse(adapter2))
paste("Adapter 2 complement:", complement(adapter2))
paste("Adapter 2 reverse complement:", reverseComplement(adapter2))
```

There are two scenarios: (1) the adapter appears as a complete sequence within the read or (2) a substring of the adapter appears within the read. Hence it is usually good practice to systematically query the reads with substrings of the adapter set. This will give us information on which positions to trim the reads.

### Trimming Adapters

`cutadapt` is a tool for trimming adapter sequences from reads. We specify the 3' adapter using the `-a` flag and the 5' adapter using the `-g` flag. The FASTQ file to be processed is passed as a positional argument.
```bash
# Trim 3' and 5' adapters
cutadapt data/f010_raw_mirna.fastq \
  -a TTTTTAGAGTGGTCTCATACAGAACTTATAAGATTCCCAAATCCAAAGACATTTCACGTTTATGGTGATTTCCCAG \ # <1>
  -g GCTTACCGTAACTTGAAAGTATTTCGATTTCTTGGCTTTATATATCTTGTGGAAAGGACGAAAAAAAG \ # <2>
  -o output/cutadapt/f010_mirna.trimmed.1.fastq \ # <3>
```
1. Trim 3' adapters
2. Trim 5' adapters
3. Save trimmed reads to destination file

We then filter by read length by specifying the minimum length (`-m`) and maximum length (`-M`). In the same command, provide a threshold for filtering out reads by quality score (`-q`).

```bash
# Filter reads by lengths and quality score
cutadapt output/cutadapt/f010_mirna.trimmed.1.fastq \
  -m 17 -M 30 \ # <1>
  -q 20 \ # <2>
  -o output/cutadapt/f010_mirna.trimmed.2.fastq \ # <3>
  --json output/cutadapt/report.json # <4>
```
1. Filter by minimum and maximum lengths, respectively
2. Filter by minimum quality score
3. Save trimmed reads to destination file
4. Save report in JSON format

As a form of due dilligence, we ensure that the adapter set (along with its substrings) are not present in the trimmed dataset using `grep`.

```bash
# Check for the presence of adapter 1 and its substrings
grep CTGGGAAATCACCATAAACGTGAAATGTCTTTGGATTTGGGAATCTTATAAGTTCTGTATGAGACCACTCTAAAAA output/cutadapt/f010_mirna.trimmed.fastq | wc -l
grep GACCCTTTAGTGGTATTTGCACTTTACAGAAACCTAAACCCTTAGAATATTCAAGACATACTCTGGTGAGATTTTT output/cutadapt/f010_mirna.trimmed.fastq | wc -l 
grep TTTTTAGAGTGGTCTCATACAGAACTTATAAGATTCCCAAATCCAAAGACATTTCACGTTTATGGTGATTTCCCAG output/cutadapt/f010_mirna.trimmed.fastq | wc -l
grep AAAAATCTCACCAGAGTATGTCTTGAATATTCTAAGGGTTTAGGTTTCTGTAAAGTGCAAATACCACTAAAGGGTC output/cutadapt/f010_mirna.trimmed.fastq | wc -l
```

```bash
# Check for the presence of adapter 2 and its substrings
grep CTTTTTTTCGTCCTTTCCACAAGATATATAAAGCCAAGAAATCGAAATACTTTCAAGTTACGGTAAGC output/cutadapt/f010_mirna.trimmed.fastq | wc -l
grep GAAAAAAAGCAGGAAAGGTGTTCTATATATTTCGGTTCTTTAGCTTTATGAAAGTTCAATGCCATTCG output/cutadapt/f010_mirna.trimmed.fastq | wc -l 
grep GCTTACCGTAACTTGAAAGTATTTCGATTTCTTGGCTTTATATATCTTGTGGAAAGGACGAAAAAAAG output/cutadapt/f010_mirna.trimmed.fastq | wc -l
grep CGAATGGCATTGAACTTTCATAAAGCTAAAGAACCGAAATATATAGAACACCTTTCCTGCTTTTTTTC output/cutadapt/f010_mirna.trimmed.fastq | wc -l 
```

A summary report is printed to the standard output of the terminal. It should resemble the following:
```
=== Summary ===

Total reads processed:                 100,000
Reads with adapters:                    80,297 (80.3%)
Reverse-complemented:                   42,949 (42.9%)

== Read fate breakdown ==
Reads that were too short:              28,068 (28.1%)
Reads that were too long:               63,771 (63.8%)
Reads written (passing filters):         8,161 (8.2%)

Total basepairs processed:    11,428,754 bp
Quality-trimmed:                  66,003 bp (0.6%)
Total written (filtered):        180,401 bp (1.6%)
```

### Exploring Trimmed Reads

We then re-run `fastqc` on the trimmed reads to verify if the matched adapter sets were removed.
```bash
# Output directory for report on trimmed reads
mkdir -p output/fastqc/trimmed

# Run fastqc on trimmed reads
fastqc -o output/fastqc/trimmed output/cutadapt/f010_mirna.trimmed.fastq 
```

The resulting report can be viewed below:

::: {.column-page}

<embed type="text/html" src="output/fastqc/trimmed/f010_mirna.trimmed.2_fastqc.html" width="100%" height="640" />

:::

---

The report confirms that reads with quality scores below 20 have been removed and only the first 30 bases were kept per read. The overrepresented sequences still persist and represent the miRNA sequences. Confirm this by querying the overrepresented sequences against an updated miRNA database.

### Read Trimming and Filtering Using `fastp`

`fastp` is an all-in-one tool designed for preprocessing and quality control of FASTQ data. It automatically detects adapter sequences in the 3' and 5' ends of the reads and performs filtering based on quality score and read length. Furthermore, it supports preprocessing of long reads (e.g., PacBio, Nanopore) and implements parallel compute. Similar to `fastqc`, the program generates a summary report in HTML format.

Simply provide the raw read data as input and specify an output directory to store the report. We could explicitly provide the adapter sequences using the `-a` flag. The minimum length, maximum length, and quality score threshold are given by the `--length_required`, `--length_limit`, and `-q` flags, respectively.
```bash
fastp -i data/f010_raw_mirna.fastq -o output/fastp/f010_mirna.trimmed.fastq \ # <1>
      --length_required 30 --length_limit 60 \ # <2>
      -q 20 \ # <3>
      --html output/fastp/fastp_report.html \ # <4>
      --json output/fastp/fastp_report.json # <5>
```
1. Process raw reads and save output to specified path
2. Specify the minimum and maximum read length, respectively
3. Specift quality score threshold
4. Generate an HTML report
5. Generate a JSON report

The summary report generated by `fastp` is minimal and simplistic. An example output for the SE dataset is provided below, giving us information on both raw and processed data:

<embed type="text/html" src="output/fastp/fastp_report.html" width="100%" height="640" />

If we do not have a list of putative adapters, we can tell `fastp` to discover existing adapters in our dataset by passing in the `--detect_adapter_for_pe` or `--detect_adapter_for_se` flag. Let us process the FASTQ files for second dataset containing PE reads.
```bash
# Run fastp on reads prefixed with "anc"
fastp --detect_adapter_for_pe \
      --overrepresentation_analysis \
      --correction --cut_right --thread 4 \
      --html output/fastp/anc.fastp.html \
      --i reads/anc_R1.fastq.gz -I reads/anc_R2.fastq.gz \
      -o output/fastp/anc_R1.trimmed.fastq.gz -O output/fastp/anc_R2.trimmed.fastq.gz

# Run fastp on reads prefixed with "evol1"
fastp --detect_adapter_for_pe \
      --overrepresentation_analysis \
      --correction --cut_right --thread 4 \
      --html output/fastp/evol1.fastp.html \
      --i reads/evol1_R1.fastq.gz -I reads/evol1_R2.fastq.gz \
      -o output/fastp/evol1_R1.trimmed.fastq.gz -O output/fastp/evol1_R2.trimmed.fastq.gz

# Run fastp on reads prefixed with "evol2"
fastp --detect_adapter_for_pe \
      --overrepresentation_analysis \
      --correction --cut_right --thread 4 \
      --html output/fastp/evol2.fastp.html \
      --i reads/evol2_R1.fastq.gz -I reads/evol2_R2.fastq.gz \
      -o output/fastp/evol2_R1.trimmed.fastq.gz -O output/fastp/evol2_R2.trimmed.fastq.gz
```

### Consolidating Reports with `multiqc`

For each trimmed FASTQ file, we could generate an individual summary report using `fastqc`. 
```bash
# Directory for PE reports
mkdir -p output/fastqc/pe/

# Run FASTQC on all gzipped FASTQC files
fastqc -o output/fastqc/pe/ output/fastp/*.fastq.gz
```

As you could imagine, it would be very laborious to inspect each output one at a time. `multiqc` makes it very easy to get a birds-eye view of all your QC reports. A path to a directory containing your `fastqc` reports serve as input and the output is an HTML file with interactive plots. We can specify the output directory using the `-o` flag.
```bash
multiqc -o output/multiqc/ output/fasqc/pe
```

Inspect the `multiqc` report below:

::: {.column-page}

<embed type="text/html" src="output/multiqc/multiqc_report.html" width="100%" height="640" />

:::

---


## Bringing It All Together

The entire workflow can be replicated by running the bash script provided below.

```bash
# Print commands and exit on error
set -uex

# Create working directory and navigate to it
mkdir qc && cd qc

# Download sequencing reads into the 'data' directory
git clone https://github.com/bioinfo-dirty-jobs/Data.git data/

# Decompress reads with gunzip
gunzip data/QUALITY/quality_control/f010_raw_mirna.fastqc.gz

# Store path to reads as variable
READS=data/QUALITY/quality_control/f010_raw_mirna.fastqc

# Create subdirectories for outputs
mkdir -p output/{fastqc,cutadapt,fastp}
mkdir -o output/fasqc/{raw,trimmed}

# Run fastq on raw reads
fastqc ${READS} -o output/fastqc/raw

# Trim adapters using cutadapt
cutadapt data/f010_raw_mirna.fastq \
  -a TTTTTAGAGTGGTCTCATACAGAACTTATAAGATTCCCAAATCCAAAGACATTTCACGTTTATGGTGATTTCCCAG \
  -g GCTTACCGTAACTTGAAAGTATTTCGATTTCTTGGCTTTATATATCTTGTGGAAAGGACGAAAAAAAG \
  -o output/cutadapt/f010_mirna.trimmed.1.fastq

# Filter reads by length and quality score using cutadapt
cutadapt output/cutadapt/f010_mirna.trimmed.1.fastq \
  -m 17 -M 30 \
  -q 20 \
  -o output/cutadapt/f010_mirna.trimmed.2.fastq \
  --json output/cutadapt/report.json

# Re-run fastqc on trimmed reads
fastqc -o output/fastqc/trimmed output/cutadapt/f010_mirna.trimmed.fastq 

# Trim and filter using fastp
fastp -i data/f010_raw_mirna.fastq -o output/fastp/f010_mirna.trimmed.fastq \ # <1>
  --length_required 30 --length_limit 60 \ # <2>
  -q 20 \ # <3>
  --html output/fastp/fastp_report.html \ # <4>
  --json output/fastp/fastp_report.json # <5>
```
