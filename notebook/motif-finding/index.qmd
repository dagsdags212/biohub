---
title: Finding Motifs in a Genetic Haystack
author: Jan Emmanuel Samson
email: jgsamson@up.edu.ph
date: 2024/10/13
last-modified: 2024/10/14
description: "Interrogating patterns in the genome with biological significance."
categories:
  - algorithms
  - sequence analysis
image: ../../assets/motif-logo.png
toc: true
execute:
  cache: true
---

# Hidden Messages in the Replication Origin

In bacteria, short regions in the genome called **DnaA boxes** act as the binding site for _DnaA_ proteins to initiate replication. The function of these segments of DNA can be experimentally verified by wet-lab scientists. However, the process of motif discovery is often costly and is prone to systematic errors. 

![](../../assets/vibrio-cholerae.jpeg){fig-align="center" width="75%" .lightbox}

::: {.column-margin}
Retrieved from \
[Emerging Pathogens Institute](https://epi.ufl.edu/events/vibrio-symposium/)
:::

The observation that regulatory regions often contain short motifs make discovery amenable to computation techniques. I will be using the _Vibrio cholerae_ genome to illustrate some approaches to motif discovery.


## Genome Data

The genome for _Vibrio cholerae_ can be downloaded [here](https://bioinformaticsalgorithms.com/data/realdatasets/Replication/Vibrio_cholerae.txt).

Load and inspect the genome:
```{python}
filepath = "assets/vibrio-cholerae.txt"
with open(filepath, "r") as handle:
  genome = handle.read().strip()
  n = 80
  lines = [genome[i:i+n] for i in range(0, 300, n)]
  for line in lines:
    print(line)
```

## K-mer Counting

A **k-mer** is a string of length _k_. It is a substring derived from a longer sequence. For example, the string _AGTAGT_ has three unique 3-mers: AGT, GTA, and TAG. The 3-mer AGT occurs twice in the sequence while the rest are only found once.

A simple way to check for motifs is to find frequently-occurring k-mers in a region of the genome. If the count of a particular k-mer is surprisingly large, we can argue that the k-mer pattern may be of biological significance. 

To count the frequency of a particular k-mer, we can create a window of size _k_ and slide it across a query sequence. At each position, we compare the the current window with the k-mer and increment a counter if they match.

```python
def pattern_count(text: str, pattern: str) -> int:
  """Counts the number of times `pattern` occurs as a substring of `text`."""
  count: int = 0
  k = len(pattern)
  for i in range(len(text)-k+1):
    if text[i:i+k] == pattern:
      count += 1
  return count
```

A more generalized approach is to set the _k_ parameter and count all k-mers in the query sequence. We then extract the most frequent k-mer by filtering for the substring with the highest count.

```{python}
def frequency_table(text: str, k: int) -> dict[str, int]:
  """Returns a frequency table containing all k-mer counts."""
  kmer_counts = {}
  for i in range(len(text)-k+1):
    kmer = text[i:i+k]
    if kmer in kmer_counts:
      kmer_counts[kmer] += 1
    else:
      kmer_counts[kmer] = 1
  # Return all k-mers sorted by count
  return kmer_counts

def get_most_frequent_kmer(freq_map: dict[str, int]) -> tuple[int, list[str]]:
  """Returns the most frequent k-mer and its counts from a frequency table. 
  If there are multiple most-frequent k-mers, return them in a list."""
  max_count = max(freq_map.values())
  most_freq_kmers = []
  for kmer, count in freq_map.items():
    if count == max_count:
      most_freq_kmers.append(kmer)
  return (max_count, most_freq_kmers)

```

Using the _V. cholerae_ origin of replication:

::: {.center}
```markdown
atcaatgatcaacgtaagcttctaagcatgatcaaggtgctcacacagtttatccacaac
ctgagtggatgacatcaagataggtcgttgtatctccttcctctcgtactctcatgacca
cggaaagatgatcaagagaggatgatttcttggccatatcgcaatgaatacttgtgactt
gtgcttccaattgacatcttcagcgccatattgcgctggccaaggtgacggagcgggatt
acgaaagcatgatcatggctgttgttctgtttatcttgttttgactgagacttgttagga
tagacggtttttcatcactgactagccaaagccttactctgcctgacatcgaccgtaaat
tgataatgaatttacatgcttccgcgacgatttacctcttgatcatcgatccgattgaag
atcttcaattgttaattctcttgcctcgactcatagccatgatgagctcttgatcatgtt
tccttaaccctctattttttacggaagaatgatcaagctgctgctcttgatcatcgtttc
```
:::

Let us find the most frequent frequent k-mers in the range $k = 3$ and $k = 9$:

```{python}
#| echo: false
def load_text(filepath: str) -> str:
  txt = ""
  with open(filepath, "r") as file:
    for line in file.readlines():
      txt += line.strip().upper()
  return txt

ori = load_text("assets/vcholerae_ori.txt")
```

```{python}
k_list = list(range(3, 10))
kmer_counts = {}
for k in k_list:
  freq_map = frequency_table(ori, k)
  kmer_counts[k] = get_most_frequent_kmer(freq_map)
```

```{python}
#| echo: false
import pandas as pd

header = []
data = {}
for k, v in kmer_counts.items():
  header.append(k)
  data[v[0]] = ", ".join(v[1])

print(data)
```

The 3-mer **TGA** is observed in 25 unique positions of the bacterial genome. Is this a suprising observation? 

Assuming that the occurrence of a nucleotide at a given position is independent of all other position, we can expect the frequency of a k-mer to decrease as _k_ increases. Given our frequency table, it is a bit surprising that four 9-mers occur three times within a 500-bp window. Furthermore, it seems that the the 9-mers `ATGATCAAG` and `CTTGATCAT` are reverse complements of each other.

Since DNA has a sense of directionality, a protein factor may bind to either forward or reverse strand of a regulatory region. In this case, `ATGATCAAG` and `CTTGATCAT` may represent the same protein binding site. Finding a 9-mer that appears six times in a DNA string of length 500 is far more surprising than finding a 9-mer that appears three time, thus supporting the working hypothesis that this region represents the _DnaA_ box in _V. cholerae_.

### Including Reverse Complements

We can update our couting function to collapse a k-mer and its reverse complement to a single count. First, we write a subroutine for getting the reverse complement of an input sequence.

```{python}
def rev_comp(seq: str) -> str:
  """Computes the reverse complement of a given DNA sequence."""
  rc = ""
  # Map N to N to deal with invalid base calls
  comp_map = {"A": "T", "T": "A", "G": "C", "C": "G", "N": "N"}
  # Prepend the complement for each base.
  for base in seq:
    rc = comp_map["base"] + rc
  return rc
```

When counting k-mers we will only keep the sequence that comes first when ordered lexicographically. For example, the 4-mer AGTC is the reverse complement of GACT. Since AGTC comes before GACT lexicographyically, we will store only the count of AGTC.


```{python}
def frequent_kmers_with_rc(text: str, k: int) -> set:
  """Returns a frequency table containing counts of all k-mers and 
  their reverse complement."""
  kmer_counts = {}
  for i in range(len(text)-k+1):
    kmer = text[i:i+k]
    kmer_rc = rev_comp(kmer)
    # Only add kmer_ref to the dictionary
    kmer_ref = None
    if kmer > kmer_rc:
      kmer_ref = kmer
    if (kmer in kmer_counts) or (kmer_rc in kmer_counts):
      kmer_counts[kmer_ref] += 1
    else:
      kmer_counts[kmer_ref] = 1
  # Return all k-mers sorted by count
  return kmer_counts
```

### Pattern Matching

Aside from computing the k-mer frequencies, we are also interested in knowning where common k-mers are located in the genome. Given an input pattern or k-mer, we keep a running list of indices at which the pattern occurs as a substring of the genome.

```{python}
def pattern_matching(pattern: str, genome: str) -> list[int]:
  """Find all occurrences of a pattern in a genome.
  Returns a list of indices that indicate the start of each match."""
  matches = []
  k = len(pattern)
  for i in range(len(genome)-k+1):
    if genome[i:i+k] == pattern:
      matches.append(i)
  return matches
```

Running the `pattern_matching` function to search all occurrences of `ATGATCAAG` in the _V. cholerae_ genome would yield the following positions:

```{python}
#| echo: false
result = pattern_matching("ATGATCAAG", genome)
print(*result)
```

Our motif `ATGATCAAG` appears 17 times in the bacterial genome. Is this sufficient evidence to confirm that this region represents a signal to bind DnaA for initiating replication?

## Verifying with Other Bacterial Genomes

We can validate our hypothesis by checking if the same motif appears in known _ori_ regions from other bacteria. This verifies that the clumping of `ATGATCAAG`/`CTTGATCAT` is not merely a result of circumstance. 

Let us check the proposed _ori_ region of _Thermotoga petrophila_, an extremophile that lives in very hot environments:
 
::: {.center}
```markdown
aactctatacctcctttttgtcgaatttgtgtgatttatagagaaaatcttattaactga
aactaaaatggtaggtttggtggtaggttttgtgtacattttgtagtatctgatttttaa
ttacataccgtatattgtattaaattgacgaacaattgcatggaattgaatatatgcaaa
acaaacctaccaccaaactctgtattgaccattttaggacaacttcagggtggtaggttt
ctgaagctctcatcaatagactattttagtctttacaaacaatattaccgttcagattca
agattctacaacgctgttttaatgggcgttgcagaaaacttaccacctaaaatccagtat
ccaagccgatttcagagaaacctaccacttacctaccacttacctaccacccgggtggta
agttgcagacattattaaaaacctcatcagaagcttgttcaaaaatttcaatactcgaaa
cctaccacctgcgtcccctattatttactactactaataatagcagtataattgatctga
```
:::

```{python}
t_petrophila_ori = load_text("assets/thermotoga_petrophila_ori.txt")
v_cholerae_motifs = ["ATGATCAAG", "CTTGATCAT"]
for motif in v_cholerae_motifs:
  result = pattern_matching(motif, t_petrophila_ori)
  if result:
    print(result)
```

Upon checking, neither `ATGATCAGG` nor its reverse complement appear once in the _ori_ site of _T. petrophila_. One possible explanation is that different motifs are responsible for initiating replicaton in different bacteria.

## Clump Finding

Instead of finding clumps of a specific k-mer, we can find every k-mer that forms a clump in the genome.

The idea is to slide a window of fixed length _L_ along the genome, looking for a region where a k-mer appears several times in short succession. The value of _L_ can vary, however empirical data suggests a length of 500 which reflects the typical length of _ori_ in bacterial genomes.

::: {.callout-tip}
# Clump Finding Problem

Find patterns forming clumps in a string.

- **Input**: A string _text_, and integers _k_, _L_, and _t_.
- **Output**: All distinct k-mers forming (_L_, _t_)-clumps in _text_.
:::

```{python}
def find_clumps(text: str, k: int, L: int, t: int) -> list[str]:
  """Return a list of k-mers that occur at least t times in a region of length L."""
  patterns = set()
  for i in range(len(text)-L+1):
    window = text[i:i+L]
    freq_map = frequency_table(window, k)
    for kmer in freq_map:
      if freq_map[kmer] >= t:
        patterns.add(kmer) 
  return list(patterns)
```

Let's find (500,3)-clumps with a k-mer size of 9 in the genome of _V cholerae_:

```{python}
# clumps = find_clumps(genome, 9, 500, 3)
# print(clumps)
```

## GC Skew

Prior to replication, DNA is unwound by the _helicase_ enzyme to separate the two sister strands. This allows other proteins such as _primase_, _ligase_, and _polymerase_ to interact with each individual strand and carry out the duplication process. 

When DNA is single-stranded, cytosine has the tendency to mutate into thymine in a process called **deamination**. 

![](https://www.researchgate.net/publication/350836790/figure/fig1/AS:1012053561053185@1618303780051/Deamination-process-Deamination-of-cytosine-left-to-uracil-right-as-caused-by.ppm){width="50%" fig-align="center"}

::: {.column-margin}
Borrowed from a [thesis by Elsa Call](https://www.researchgate.net/publication/350836790_The_Age_of_Museomics_-_How_to_get_genomic_information_from_museum_specimens_of_Lepidoptera)
:::

The converted thymine is then paired with an adenine, leading to a discrepancy in the GC content of the reverse half-strand. This is known as the GC skew.


How can we use this to identify the _ori_ site of bacteria?


The idea stems from the observation that the forward and reverse half-strands of a bacterial genome is demarcated by the origin and terminus of replication. The forward half-strand traverses the genome in the 5' ⟶ 3' direction while the reverse half-strand follows the opposite direction (3' ⟶ 5'). Due to the asymmetry of the replication process, deamination occurs more frequently in the reverse half-strands resulting in an increase in cytosine. By dividing the genome into equally-sized bins and computing the difference in the counts of guanine and cytosine, we can get an idea of where we are in the genome.

![](https://bioinformaticsalgorithms.com/images/Replication/ecoli_frequency_difference.png){width="95%" fig-align="center"}

::: {.column-margin}
Borrowed from Dr. Pavel Pevzner's course _Bioinformatics Algorithms_.
:::

### The Skew Array

The skew array keeps a running measurement of the _skew_ value while "walking" the length of a genome. The _skew_ value is computed as follows:

$$ \text{skew} = \text{count}_G - \text{count}_C $$

If the _skew_ value is increasing, then we guess that we are on the forward half-strand. Otherwise, we guess that we are on the reverse half-strand. 

![](https://bioinformaticsalgorithms.com/images/Replication/increasing_decreasing_skew.png){width="95%" fig-align="center"}

::: {.column-margin}
Borrowed from Dr. Pavel Pevzner's course _Bioinformatics Algorithms_.
:::

As an example, consider the DNA string `CATGGGCATCGGCCATACGCC`. We compute the skew values starting from the first position up to the length of the string. At position zero, we initialize the skew value as follows:


$$
\begin{equation}
\text{skew}_0 = 
  \begin{cases}
    0  & \text{if $\text{genome}_0 \in \{A,T\}$} \\
    +1 & \text{if $\text{genome}_0 = G$} \\  
    -1 & \text{if $\text{genome}_0 = C$} \\  
  \end{cases}
\end{equation}
$$

Since our sequence starts with `C`, we set $\text{skew}_0 = -1$. Computing the skew at the $i^{th}$ position can be simplified by considering the skew of the previous position and updating the value based on the following conditions:

$$
\begin{equation}
  \text{skew}_i =
  \begin{cases}
    \text{skew}_{i-1} & \text{if $\text{genome}_i \in \{A,T\}$} \\
    \text{skew}_{i-1} + 1 & \text{if $\text{genome}_i = G$} \\
    \text{skew}_{i-1} - 1 & \text{if $\text{genome}_i = C$} \\
  \end{cases}
\end{equation}
$$

Based on our rules, the first five elements of the skew array can be computed as \[-1, -1, -1, 0, 1\]. The code implementation is provided below.

```{python}
def skew_array(text: str) -> list[int]:
  """Computes the total count difference of G and C."""
  skew_values = [0]
  for base in text.upper():
    if base == "G":
      skew_values.append(skew_values[-1]+1)
    elif base == "C":
      skew_values.append(skew_values[-1]-1)
    else:
      skew_values.append(skew_values[-1])
  return skew_values
```

### Visualizing the Skew Array

The skew array can be visualized by plotting the _skew_ values against the current genome position. Applying this to the linearized genome of _E. coli_, we get the following graph:

![](https://bioinformaticsalgorithms.com/images/Replication/skew_diagram_ecoli.png){width="95%" fig-align="center"}


By finding the range where the skew value transitions from decreasing to increasing, we can identify the position of the _ori_ site of _E. coli_. Another way to think about the problem is to find the genome position corresponding to the **global minimum** of the skew array. 

Similarly, the _ter_ region (terminus of replication) can be framed as a maximization problem. To solve this, we find the genomic location at which we observe the highest _skew_ value in the array.

## Approximate Matching

::: {.callout-tip}
# In Progress
:::
